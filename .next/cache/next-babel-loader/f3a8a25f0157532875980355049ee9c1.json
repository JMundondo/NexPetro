{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nexports.__esModule = true;\nexports.default = exports.looseToArray = void 0;\n\nvar _mitt = _interopRequireDefault(require(\"../next-server/lib/mitt\"));\n\nvar _router = require(\"../next-server/lib/router/router\");\n\nvar _getAssetPathFromRoute = _interopRequireDefault(require(\"../next-server/lib/router/utils/get-asset-path-from-route\"));\n\nvar _isDynamic = require(\"../next-server/lib/router/utils/is-dynamic\");\n\nvar _parseRelativeUrl = require(\"../next-server/lib/router/utils/parse-relative-url\");\n\nconst looseToArray = input => [].slice.call(input);\n\nexports.looseToArray = looseToArray;\n\nfunction getInitialStylesheets() {\n  return looseToArray(document.styleSheets).filter(el => el.ownerNode && el.ownerNode.tagName === 'LINK' && el.ownerNode.hasAttribute('data-n-p')).map(sheet => ({\n    href: sheet.ownerNode.getAttribute('href'),\n    text: looseToArray(sheet.cssRules).map(r => r.cssText).join('')\n  }));\n}\n\nfunction hasRel(rel, link) {\n  try {\n    link = document.createElement('link');\n    return link.relList.supports(rel);\n  } catch (_unused) {}\n}\n\nfunction pageLoadError(route) {\n  return (0, _router.markLoadingError)(new Error(`Error loading ${route}`));\n}\n\nconst relPrefetch = hasRel('preload') && !hasRel('prefetch') ? // https://caniuse.com/#feat=link-rel-preload\n// macOS and iOS (Safari does not support prefetch)\n'preload' : // https://caniuse.com/#feat=link-rel-prefetch\n// IE 11, Edge 12+, nearly all evergreen\n'prefetch';\nconst relPreload = hasRel('preload') ? 'preload' : relPrefetch;\nconst relPreloadStyle = 'fetch';\nconst hasNoModule = ('noModule' in document.createElement('script'));\n\nfunction normalizeRoute(route) {\n  if (route[0] !== '/') {\n    throw new Error(`Route name should start with a \"/\", got \"${route}\"`);\n  }\n\n  if (route === '/') return route;\n  return route.replace(/\\/$/, '');\n}\n\nfunction appendLink(href, rel, as, link) {\n  return new Promise((res, rej) => {\n    link = document.createElement('link'); // The order of property assignment here is intentional:\n\n    if (as) link.as = as;\n    link.rel = rel;\n    link.crossOrigin = process.env.__NEXT_CROSS_ORIGIN;\n    link.onload = res;\n    link.onerror = rej; // `href` should always be last:\n\n    link.href = href;\n    document.head.appendChild(link);\n  });\n}\n\nfunction loadScript(url) {\n  return new Promise((res, rej) => {\n    const script = document.createElement('script');\n\n    if (process.env.__NEXT_MODERN_BUILD && hasNoModule) {\n      script.type = 'module';\n    }\n\n    script.crossOrigin = process.env.__NEXT_CROSS_ORIGIN;\n    script.src = url;\n    script.onload = res;\n\n    script.onerror = () => rej(pageLoadError(url));\n\n    document.body.appendChild(script);\n  });\n}\n\nclass PageLoader {\n  constructor(buildId, assetPrefix, initialPage) {\n    this.initialPage = void 0;\n    this.buildId = void 0;\n    this.assetPrefix = void 0;\n    this.pageCache = void 0;\n    this.pageRegisterEvents = void 0;\n    this.loadingRoutes = void 0;\n    this.promisedBuildManifest = void 0;\n    this.promisedSsgManifest = void 0;\n    this.promisedDevPagesManifest = void 0;\n    this.initialPage = initialPage;\n    this.buildId = buildId;\n    this.assetPrefix = assetPrefix;\n    this.pageCache = {};\n    this.pageRegisterEvents = (0, _mitt.default)();\n    this.loadingRoutes = {\n      // By default these 2 pages are being loaded in the initial html\n      '/_app': true\n    }; // TODO: get rid of this limitation for rendering the error page\n\n    if (initialPage !== '/_error') {\n      this.loadingRoutes[initialPage] = true;\n    }\n\n    this.promisedBuildManifest = new Promise(resolve => {\n      if (window.__BUILD_MANIFEST) {\n        resolve(window.__BUILD_MANIFEST);\n      } else {\n        ;\n\n        window.__BUILD_MANIFEST_CB = () => {\n          resolve(window.__BUILD_MANIFEST);\n        };\n      }\n    });\n    /** @type {Promise<Set<string>>} */\n\n    this.promisedSsgManifest = new Promise(resolve => {\n      if (window.__SSG_MANIFEST) {\n        resolve(window.__SSG_MANIFEST);\n      } else {\n        ;\n\n        window.__SSG_MANIFEST_CB = () => {\n          resolve(window.__SSG_MANIFEST);\n        };\n      }\n    });\n  }\n\n  getPageList() {\n    if (false) {\n      return this.promisedBuildManifest.then(buildManifest => buildManifest.sortedPages);\n    } else {\n      if (window.__DEV_PAGES_MANIFEST) {\n        return window.__DEV_PAGES_MANIFEST.pages;\n      } else {\n        if (!this.promisedDevPagesManifest) {\n          this.promisedDevPagesManifest = fetch(`${this.assetPrefix}/_next/static/development/_devPagesManifest.json`).then(res => res.json()).then(manifest => {\n            ;\n            window.__DEV_PAGES_MANIFEST = manifest;\n            return manifest.pages;\n          }).catch(err => {\n            console.log(`Failed to fetch devPagesManifest`, err);\n          });\n        }\n\n        return this.promisedDevPagesManifest;\n      }\n    }\n  } // Returns a promise for the dependencies for a particular route\n\n\n  getDependencies(route) {\n    return this.promisedBuildManifest.then(m => {\n      return m[route] ? m[route].map(url => `${this.assetPrefix}/_next/${encodeURI(url)}`) : Promise.reject(pageLoadError(route));\n    });\n  }\n  /**\n  * @param {string} href the route href (file-system path)\n  * @param {string} asPath the URL as shown in browser (virtual path); used for dynamic routes\n  */\n\n\n  getDataHref(href, asPath, ssg, locale, defaultLocale) {\n    const {\n      pathname: hrefPathname,\n      query,\n      search\n    } = (0, _parseRelativeUrl.parseRelativeUrl)(href);\n    const {\n      pathname: asPathname\n    } = (0, _parseRelativeUrl.parseRelativeUrl)(asPath);\n    const route = normalizeRoute(hrefPathname);\n\n    const getHrefForSlug = path => {\n      const dataRoute = (0, _router.addLocale)((0, _getAssetPathFromRoute.default)(path, '.json'), locale, defaultLocale);\n      return (0, _router.addBasePath)(`/_next/data/${this.buildId}${dataRoute}${ssg ? '' : search}`);\n    };\n\n    const isDynamic = (0, _isDynamic.isDynamicRoute)(route);\n    const interpolatedRoute = isDynamic ? (0, _router.interpolateAs)(hrefPathname, asPathname, query).result : '';\n    return isDynamic ? interpolatedRoute && getHrefForSlug(interpolatedRoute) : getHrefForSlug(route);\n  }\n  /**\n  * @param {string} href the route href (file-system path)\n  * @param {string} asPath the URL as shown in browser (virtual path); used for dynamic routes\n  */\n\n\n  prefetchData(href, asPath, locale, defaultLocale) {\n    const {\n      pathname: hrefPathname\n    } = (0, _parseRelativeUrl.parseRelativeUrl)(href);\n    const route = normalizeRoute(hrefPathname);\n    return this.promisedSsgManifest.then((s, _dataHref) => // Check if the route requires a data file\n    s.has(route) && ( // Try to generate data href, noop when falsy\n    _dataHref = this.getDataHref(href, asPath, true, locale, defaultLocale)) && // noop when data has already been prefetched (dedupe)\n    !document.querySelector(`link[rel=\"${relPrefetch}\"][href^=\"${_dataHref}\"]`) && // Inject the `<link rel=prefetch>` tag for above computed `href`.\n    appendLink(_dataHref, relPrefetch, 'fetch').catch(() => {\n      /* ignore prefetch error */\n    }));\n  }\n\n  loadPage(route) {\n    route = normalizeRoute(route);\n    return new Promise((resolve, reject) => {\n      // If there's a cached version of the page, let's use it.\n      const cachedPage = this.pageCache[route];\n\n      if (cachedPage) {\n        if ('error' in cachedPage) {\n          reject(cachedPage.error);\n        } else {\n          resolve(cachedPage);\n        }\n\n        return;\n      }\n\n      const fire = pageToCache => {\n        this.pageRegisterEvents.off(route, fire);\n        delete this.loadingRoutes[route];\n\n        if ('error' in pageToCache) {\n          reject(pageToCache.error);\n        } else {\n          resolve(pageToCache);\n        }\n      }; // Register a listener to get the page\n\n\n      this.pageRegisterEvents.on(route, fire);\n\n      if (!this.loadingRoutes[route]) {\n        this.loadingRoutes[route] = true;\n\n        if (false) {\n          this.getDependencies(route).then(deps => {\n            const pending = [];\n            deps.forEach(d => {\n              if (d.endsWith('.js') && !document.querySelector(`script[src^=\"${d}\"]`)) {\n                pending.push(loadScript(d));\n              } // Prefetch CSS as it'll be needed when the page JavaScript\n              // evaluates. This will only trigger if explicit prefetching is\n              // disabled for a <Link>... prefetching in this case is desirable\n              // because we *know* it's going to be used very soon (page was\n              // loaded).\n\n\n              if (d.endsWith('.css') && !document.querySelector(`link[rel=\"${relPreload}\"][href^=\"${d}\"]`)) {\n                // This is not pushed into `pending` because we don't need to\n                // wait for these to resolve. To prevent an unhandled\n                // rejection, we swallow the error which is handled later in\n                // the rendering cycle (this is just a preload optimization).\n                appendLink(d, relPreload, relPreloadStyle).catch(() => {\n                  /* ignore preload error */\n                });\n              }\n            });\n            return Promise.all(pending);\n          }).catch(err => {\n            // Mark the page as failed to load if any of its required scripts\n            // fail to load:\n            this.pageCache[route] = {\n              error: err\n            };\n            fire({\n              error: err\n            });\n          });\n        } else {\n          // Development only. In production the page file is part of the build manifest\n          route = normalizeRoute(route);\n          let scriptRoute = (0, _getAssetPathFromRoute.default)(route, '.js');\n          const url = `${this.assetPrefix}/_next/static/chunks/pages${encodeURI(scriptRoute)}`;\n          loadScript(url).catch(err => {\n            // Mark the page as failed to load if its script fails to load:\n            this.pageCache[route] = {\n              error: err\n            };\n            fire({\n              error: err\n            });\n          });\n        }\n      }\n    });\n  } // This method if called by the route code.\n\n\n  registerPage(route, regFn) {\n    const register = styleSheets => {\n      try {\n        const mod = regFn();\n        const pageData = {\n          page: mod.default || mod,\n          mod,\n          styleSheets\n        };\n        this.pageCache[route] = pageData;\n        this.pageRegisterEvents.emit(route, pageData);\n      } catch (error) {\n        this.pageCache[route] = {\n          error\n        };\n        this.pageRegisterEvents.emit(route, {\n          error\n        });\n      }\n    };\n\n    if (true) {\n      // Wait for webpack to become idle if it's not.\n      // More info: https://github.com/vercel/next.js/pull/1511\n      if (module.hot && module.hot.status() !== 'idle') {\n        console.log(`Waiting for webpack to become \"idle\" to initialize the page: \"${route}\"`);\n\n        const check = status => {\n          if (status === 'idle') {\n            ;\n            module.hot.removeStatusHandler(check);\n            register(\n            /* css is handled via style-loader in development */\n            []);\n          }\n        };\n\n        module.hot.status(check);\n        return;\n      }\n    }\n\n    function fetchStyleSheet(href) {\n      return fetch(href).then(res => {\n        if (!res.ok) throw pageLoadError(href);\n        return res.text().then(text => ({\n          href,\n          text\n        }));\n      });\n    }\n\n    const isInitialLoad = route === this.initialPage;\n    const promisedDeps = // Shared styles will already be on the page:\n    route === '/_app' || // We use `style-loader` in development:\n    true ? Promise.resolve([]) : // Tests that this does not block hydration:\n    // test/integration/css-fixtures/hydrate-without-deps/\n    (isInitialLoad ? Promise.resolve(looseToArray(document.querySelectorAll('link[data-n-p]')).map(e => e.getAttribute('href'))) : this.getDependencies(route).then(deps => deps.filter(d => d.endsWith('.css')))).then(cssFiles => // These files should've already been fetched by now, so this\n    // should resolve instantly.\n    Promise.all(cssFiles.map(d => fetchStyleSheet(d))).catch(err => {\n      if (isInitialLoad) return getInitialStylesheets();\n      throw err;\n    }));\n    promisedDeps.then(deps => register(deps), error => {\n      this.pageCache[route] = {\n        error\n      };\n      this.pageRegisterEvents.emit(route, {\n        error\n      });\n    });\n  }\n  /**\n  * @param {string} route\n  * @param {boolean} [isDependency]\n  */\n\n\n  prefetch(route, isDependency) {\n    // https://github.com/GoogleChromeLabs/quicklink/blob/453a661fa1fa940e2d2e044452398e38c67a98fb/src/index.mjs#L115-L118\n    // License: Apache 2.0\n    let cn;\n\n    if (cn = navigator.connection) {\n      // Don't prefetch if using 2G or if Save-Data is enabled.\n      if (cn.saveData || /2g/.test(cn.effectiveType)) return Promise.resolve();\n    }\n    /** @type {string} */\n\n\n    let url;\n\n    if (isDependency) {\n      url = route;\n    } else {\n      if (true) {\n        route = normalizeRoute(route);\n        const ext = process.env.__NEXT_MODERN_BUILD && hasNoModule ? '.module.js' : '.js';\n        const scriptRoute = (0, _getAssetPathFromRoute.default)(route, ext);\n        url = `${this.assetPrefix}/_next/static/${encodeURIComponent(this.buildId)}/pages${encodeURI(scriptRoute)}`;\n      }\n    }\n\n    return Promise.all(document.querySelector(`link[rel=\"${relPrefetch}\"][href^=\"${url}\"]`) ? [] : [url && appendLink(url, relPrefetch, url.endsWith('.css') ? relPreloadStyle : 'script'), false && !isDependency && this.getDependencies(route).then(urls => Promise.all(urls.map(dependencyUrl => this.prefetch(dependencyUrl, true))))]).then( // do not return any data\n    () => {}, // swallow prefetch errors\n    () => {});\n  }\n\n}\n\nexports.default = PageLoader;","map":{"version":3,"sources":["../../client/page-loader.ts"],"names":["looseToArray","input","document","el","sheet","href","text","r","link","route","relPrefetch","hasRel","relPreload","relPreloadStyle","hasNoModule","process","script","rej","pageLoadError","PageLoader","initialPage","buildId","assetPrefix","pageCache","pageRegisterEvents","loadingRoutes","promisedBuildManifest","promisedSsgManifest","promisedDevPagesManifest","constructor","resolve","window","getPageList","buildManifest","fetch","res","manifest","err","console","getDependencies","m","url","encodeURI","Promise","getDataHref","pathname","normalizeRoute","getHrefForSlug","path","dataRoute","ssg","search","isDynamic","interpolatedRoute","prefetchData","s","_dataHref","appendLink","loadPage","cachedPage","reject","fire","pageToCache","deps","pending","d","loadScript","error","scriptRoute","registerPage","register","styleSheets","mod","regFn","pageData","page","module","check","status","isInitialLoad","promisedDeps","e","cssFiles","fetchStyleSheet","getInitialStylesheets","prefetch","cn","navigator","ext","encodeURIComponent","urls","dependencyUrl"],"mappings":"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","sourcesContent":["import { ComponentType } from 'react'\nimport type { ClientSsgManifest } from '../build'\nimport type { ClientBuildManifest } from '../build/webpack/plugins/build-manifest-plugin'\nimport mitt from '../next-server/lib/mitt'\nimport type { MittEmitter } from '../next-server/lib/mitt'\nimport {\n  addBasePath,\n  markLoadingError,\n  interpolateAs,\n  addLocale,\n} from '../next-server/lib/router/router'\n\nimport getAssetPathFromRoute from '../next-server/lib/router/utils/get-asset-path-from-route'\nimport { isDynamicRoute } from '../next-server/lib/router/utils/is-dynamic'\nimport { parseRelativeUrl } from '../next-server/lib/router/utils/parse-relative-url'\n\nexport const looseToArray = <T extends {}>(input: any): T[] =>\n  [].slice.call(input)\n\nfunction getInitialStylesheets(): StyleSheetTuple[] {\n  return looseToArray<CSSStyleSheet>(document.styleSheets)\n    .filter(\n      (el: CSSStyleSheet) =>\n        el.ownerNode &&\n        (el.ownerNode as Element).tagName === 'LINK' &&\n        (el.ownerNode as Element).hasAttribute('data-n-p')\n    )\n    .map((sheet) => ({\n      href: (sheet.ownerNode as Element).getAttribute('href')!,\n      text: looseToArray<CSSRule>(sheet.cssRules)\n        .map((r) => r.cssText)\n        .join(''),\n    }))\n}\n\nfunction hasRel(rel: string, link?: HTMLLinkElement) {\n  try {\n    link = document.createElement('link')\n    return link.relList.supports(rel)\n  } catch {}\n}\n\nfunction pageLoadError(route: string) {\n  return markLoadingError(new Error(`Error loading ${route}`))\n}\n\nconst relPrefetch =\n  hasRel('preload') && !hasRel('prefetch')\n    ? // https://caniuse.com/#feat=link-rel-preload\n      // macOS and iOS (Safari does not support prefetch)\n      'preload'\n    : // https://caniuse.com/#feat=link-rel-prefetch\n      // IE 11, Edge 12+, nearly all evergreen\n      'prefetch'\n\nconst relPreload = hasRel('preload') ? 'preload' : relPrefetch\nconst relPreloadStyle = 'fetch'\n\nconst hasNoModule = 'noModule' in document.createElement('script')\n\nfunction normalizeRoute(route: string) {\n  if (route[0] !== '/') {\n    throw new Error(`Route name should start with a \"/\", got \"${route}\"`)\n  }\n\n  if (route === '/') return route\n  return route.replace(/\\/$/, '')\n}\n\nfunction appendLink(\n  href: string,\n  rel: string,\n  as?: string,\n  link?: HTMLLinkElement\n): Promise<any> {\n  return new Promise((res, rej) => {\n    link = document.createElement('link')\n\n    // The order of property assignment here is intentional:\n    if (as) link!.as = as\n    link!.rel = rel\n    link!.crossOrigin = process.env.__NEXT_CROSS_ORIGIN!\n    link!.onload = res\n    link!.onerror = rej\n\n    // `href` should always be last:\n    link!.href = href\n\n    document.head.appendChild(link)\n  })\n}\n\nfunction loadScript(url: string): Promise<any> {\n  return new Promise((res, rej) => {\n    const script = document.createElement('script')\n    if (process.env.__NEXT_MODERN_BUILD && hasNoModule) {\n      script.type = 'module'\n    }\n    script.crossOrigin = process.env.__NEXT_CROSS_ORIGIN!\n    script.src = url\n    script.onload = res\n    script.onerror = () => rej(pageLoadError(url))\n    document.body.appendChild(script)\n  })\n}\n\nexport type StyleSheetTuple = { href: string; text: string }\nexport type GoodPageCache = {\n  page: ComponentType\n  mod: any\n  styleSheets: StyleSheetTuple[]\n}\nexport type PageCacheEntry = { error: any } | GoodPageCache\n\nexport default class PageLoader {\n  private initialPage: string\n  private buildId: string\n  private assetPrefix: string\n  private pageCache: Record<string, PageCacheEntry>\n  private pageRegisterEvents: MittEmitter\n  private loadingRoutes: Record<string, boolean>\n  private promisedBuildManifest?: Promise<ClientBuildManifest>\n  private promisedSsgManifest?: Promise<ClientSsgManifest>\n  private promisedDevPagesManifest?: Promise<any>\n\n  constructor(buildId: string, assetPrefix: string, initialPage: string) {\n    this.initialPage = initialPage\n\n    this.buildId = buildId\n    this.assetPrefix = assetPrefix\n\n    this.pageCache = {}\n    this.pageRegisterEvents = mitt()\n    this.loadingRoutes = {\n      // By default these 2 pages are being loaded in the initial html\n      '/_app': true,\n    }\n\n    // TODO: get rid of this limitation for rendering the error page\n    if (initialPage !== '/_error') {\n      this.loadingRoutes[initialPage] = true\n    }\n\n    this.promisedBuildManifest = new Promise((resolve) => {\n      if ((window as any).__BUILD_MANIFEST) {\n        resolve((window as any).__BUILD_MANIFEST)\n      } else {\n        ;(window as any).__BUILD_MANIFEST_CB = () => {\n          resolve((window as any).__BUILD_MANIFEST)\n        }\n      }\n    })\n\n    /** @type {Promise<Set<string>>} */\n    this.promisedSsgManifest = new Promise((resolve) => {\n      if ((window as any).__SSG_MANIFEST) {\n        resolve((window as any).__SSG_MANIFEST)\n      } else {\n        ;(window as any).__SSG_MANIFEST_CB = () => {\n          resolve((window as any).__SSG_MANIFEST)\n        }\n      }\n    })\n  }\n\n  getPageList() {\n    if (process.env.NODE_ENV === 'production') {\n      return this.promisedBuildManifest!.then(\n        (buildManifest) => buildManifest.sortedPages\n      )\n    } else {\n      if ((window as any).__DEV_PAGES_MANIFEST) {\n        return (window as any).__DEV_PAGES_MANIFEST.pages\n      } else {\n        if (!this.promisedDevPagesManifest) {\n          this.promisedDevPagesManifest = fetch(\n            `${this.assetPrefix}/_next/static/development/_devPagesManifest.json`\n          )\n            .then((res) => res.json())\n            .then((manifest) => {\n              ;(window as any).__DEV_PAGES_MANIFEST = manifest\n              return manifest.pages\n            })\n            .catch((err) => {\n              console.log(`Failed to fetch devPagesManifest`, err)\n            })\n        }\n        return this.promisedDevPagesManifest\n      }\n    }\n  }\n\n  // Returns a promise for the dependencies for a particular route\n  private getDependencies(route: string): Promise<string[]> {\n    return this.promisedBuildManifest!.then((m) => {\n      return m[route]\n        ? m[route].map((url) => `${this.assetPrefix}/_next/${encodeURI(url)}`)\n        : Promise.reject(pageLoadError(route))\n    })\n  }\n\n  /**\n   * @param {string} href the route href (file-system path)\n   * @param {string} asPath the URL as shown in browser (virtual path); used for dynamic routes\n   */\n  getDataHref(\n    href: string,\n    asPath: string,\n    ssg: boolean,\n    locale?: string,\n    defaultLocale?: string\n  ) {\n    const { pathname: hrefPathname, query, search } = parseRelativeUrl(href)\n    const { pathname: asPathname } = parseRelativeUrl(asPath)\n    const route = normalizeRoute(hrefPathname)\n\n    const getHrefForSlug = (path: string) => {\n      const dataRoute = addLocale(\n        getAssetPathFromRoute(path, '.json'),\n        locale,\n        defaultLocale\n      )\n      return addBasePath(\n        `/_next/data/${this.buildId}${dataRoute}${ssg ? '' : search}`\n      )\n    }\n\n    const isDynamic: boolean = isDynamicRoute(route)\n    const interpolatedRoute = isDynamic\n      ? interpolateAs(hrefPathname, asPathname, query).result\n      : ''\n\n    return isDynamic\n      ? interpolatedRoute && getHrefForSlug(interpolatedRoute)\n      : getHrefForSlug(route)\n  }\n\n  /**\n   * @param {string} href the route href (file-system path)\n   * @param {string} asPath the URL as shown in browser (virtual path); used for dynamic routes\n   */\n  prefetchData(\n    href: string,\n    asPath: string,\n    locale?: string,\n    defaultLocale?: string\n  ) {\n    const { pathname: hrefPathname } = parseRelativeUrl(href)\n    const route = normalizeRoute(hrefPathname)\n    return this.promisedSsgManifest!.then(\n      (s: ClientSsgManifest, _dataHref?: string) =>\n        // Check if the route requires a data file\n        s.has(route) &&\n        // Try to generate data href, noop when falsy\n        (_dataHref = this.getDataHref(\n          href,\n          asPath,\n          true,\n          locale,\n          defaultLocale\n        )) &&\n        // noop when data has already been prefetched (dedupe)\n        !document.querySelector(\n          `link[rel=\"${relPrefetch}\"][href^=\"${_dataHref}\"]`\n        ) &&\n        // Inject the `<link rel=prefetch>` tag for above computed `href`.\n        appendLink(_dataHref, relPrefetch, 'fetch').catch(() => {\n          /* ignore prefetch error */\n        })\n    )\n  }\n\n  loadPage(route: string): Promise<GoodPageCache> {\n    route = normalizeRoute(route)\n\n    return new Promise<GoodPageCache>((resolve, reject) => {\n      // If there's a cached version of the page, let's use it.\n      const cachedPage = this.pageCache[route]\n      if (cachedPage) {\n        if ('error' in cachedPage) {\n          reject(cachedPage.error)\n        } else {\n          resolve(cachedPage)\n        }\n        return\n      }\n\n      const fire = (pageToCache: PageCacheEntry) => {\n        this.pageRegisterEvents.off(route, fire)\n        delete this.loadingRoutes[route]\n\n        if ('error' in pageToCache) {\n          reject(pageToCache.error)\n        } else {\n          resolve(pageToCache)\n        }\n      }\n\n      // Register a listener to get the page\n      this.pageRegisterEvents.on(route, fire)\n\n      if (!this.loadingRoutes[route]) {\n        this.loadingRoutes[route] = true\n        if (process.env.NODE_ENV === 'production') {\n          this.getDependencies(route)\n            .then((deps) => {\n              const pending: Promise<any>[] = []\n              deps.forEach((d) => {\n                if (\n                  d.endsWith('.js') &&\n                  !document.querySelector(`script[src^=\"${d}\"]`)\n                ) {\n                  pending.push(loadScript(d))\n                }\n\n                // Prefetch CSS as it'll be needed when the page JavaScript\n                // evaluates. This will only trigger if explicit prefetching is\n                // disabled for a <Link>... prefetching in this case is desirable\n                // because we *know* it's going to be used very soon (page was\n                // loaded).\n                if (\n                  d.endsWith('.css') &&\n                  !document.querySelector(\n                    `link[rel=\"${relPreload}\"][href^=\"${d}\"]`\n                  )\n                ) {\n                  // This is not pushed into `pending` because we don't need to\n                  // wait for these to resolve. To prevent an unhandled\n                  // rejection, we swallow the error which is handled later in\n                  // the rendering cycle (this is just a preload optimization).\n                  appendLink(d, relPreload, relPreloadStyle).catch(() => {\n                    /* ignore preload error */\n                  })\n                }\n              })\n              return Promise.all(pending)\n            })\n            .catch((err) => {\n              // Mark the page as failed to load if any of its required scripts\n              // fail to load:\n              this.pageCache[route] = { error: err }\n              fire({ error: err })\n            })\n        } else {\n          // Development only. In production the page file is part of the build manifest\n          route = normalizeRoute(route)\n          let scriptRoute = getAssetPathFromRoute(route, '.js')\n\n          const url = `${this.assetPrefix}/_next/static/chunks/pages${encodeURI(\n            scriptRoute\n          )}`\n          loadScript(url).catch((err) => {\n            // Mark the page as failed to load if its script fails to load:\n            this.pageCache[route] = { error: err }\n            fire({ error: err })\n          })\n        }\n      }\n    })\n  }\n\n  // This method if called by the route code.\n  registerPage(route: string, regFn: () => any) {\n    const register = (styleSheets: StyleSheetTuple[]) => {\n      try {\n        const mod = regFn()\n        const pageData: PageCacheEntry = {\n          page: mod.default || mod,\n          mod,\n          styleSheets,\n        }\n        this.pageCache[route] = pageData\n        this.pageRegisterEvents.emit(route, pageData)\n      } catch (error) {\n        this.pageCache[route] = { error }\n        this.pageRegisterEvents.emit(route, { error })\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      // Wait for webpack to become idle if it's not.\n      // More info: https://github.com/vercel/next.js/pull/1511\n      if ((module as any).hot && (module as any).hot.status() !== 'idle') {\n        console.log(\n          `Waiting for webpack to become \"idle\" to initialize the page: \"${route}\"`\n        )\n\n        const check = (status: string) => {\n          if (status === 'idle') {\n            ;(module as any).hot.removeStatusHandler(check)\n            register(\n              /* css is handled via style-loader in development */\n              []\n            )\n          }\n        }\n        ;(module as any).hot.status(check)\n        return\n      }\n    }\n\n    function fetchStyleSheet(href: string): Promise<StyleSheetTuple> {\n      return fetch(href).then((res) => {\n        if (!res.ok) throw pageLoadError(href)\n        return res.text().then((text) => ({ href, text }))\n      })\n    }\n\n    const isInitialLoad = route === this.initialPage\n    const promisedDeps: Promise<StyleSheetTuple[]> =\n      // Shared styles will already be on the page:\n      route === '/_app' ||\n      // We use `style-loader` in development:\n      process.env.NODE_ENV !== 'production'\n        ? Promise.resolve([])\n        : // Tests that this does not block hydration:\n          // test/integration/css-fixtures/hydrate-without-deps/\n          (isInitialLoad\n            ? Promise.resolve(\n                looseToArray<HTMLLinkElement>(\n                  document.querySelectorAll('link[data-n-p]')\n                ).map((e) => e.getAttribute('href')!)\n              )\n            : this.getDependencies(route).then((deps) =>\n                deps.filter((d) => d.endsWith('.css'))\n              )\n          ).then((cssFiles) =>\n            // These files should've already been fetched by now, so this\n            // should resolve instantly.\n            Promise.all(cssFiles.map((d) => fetchStyleSheet(d))).catch(\n              (err) => {\n                if (isInitialLoad) return getInitialStylesheets()\n                throw err\n              }\n            )\n          )\n    promisedDeps.then(\n      (deps) => register(deps),\n      (error) => {\n        this.pageCache[route] = { error }\n        this.pageRegisterEvents.emit(route, { error })\n      }\n    )\n  }\n\n  /**\n   * @param {string} route\n   * @param {boolean} [isDependency]\n   */\n  prefetch(route: string, isDependency?: boolean): Promise<void> {\n    // https://github.com/GoogleChromeLabs/quicklink/blob/453a661fa1fa940e2d2e044452398e38c67a98fb/src/index.mjs#L115-L118\n    // License: Apache 2.0\n    let cn\n    if ((cn = (navigator as any).connection)) {\n      // Don't prefetch if using 2G or if Save-Data is enabled.\n      if (cn.saveData || /2g/.test(cn.effectiveType)) return Promise.resolve()\n    }\n\n    /** @type {string} */\n    let url\n    if (isDependency) {\n      url = route\n    } else {\n      if (process.env.NODE_ENV !== 'production') {\n        route = normalizeRoute(route)\n\n        const ext =\n          process.env.__NEXT_MODERN_BUILD && hasNoModule ? '.module.js' : '.js'\n        const scriptRoute = getAssetPathFromRoute(route, ext)\n\n        url = `${this.assetPrefix}/_next/static/${encodeURIComponent(\n          this.buildId\n        )}/pages${encodeURI(scriptRoute)}`\n      }\n    }\n\n    return Promise.all(\n      document.querySelector(`link[rel=\"${relPrefetch}\"][href^=\"${url}\"]`)\n        ? []\n        : [\n            url &&\n              appendLink(\n                url,\n                relPrefetch,\n                url.endsWith('.css') ? relPreloadStyle : 'script'\n              ),\n            process.env.NODE_ENV === 'production' &&\n              !isDependency &&\n              this.getDependencies(route).then((urls) =>\n                Promise.all(\n                  urls.map((dependencyUrl) =>\n                    this.prefetch(dependencyUrl, true)\n                  )\n                )\n              ),\n          ]\n    ).then(\n      // do not return any data\n      () => {},\n      // swallow prefetch errors\n      () => {}\n    )\n  }\n}\n"]},"metadata":{},"sourceType":"script"}